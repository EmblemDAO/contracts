const { expect } = require("chai");
const { solidityKeccak256 } = require("ethers/lib/utils");
const { ethers } = require("hardhat");
const { gql, request, GraphQLClient } = require("graphql-request");
const { MerkleTree } = require('merkletreejs')
const keccak256 = require('keccak256')



const BADGETH_LIBRARY_CONTRACT_NAME = "BadgethLibrary";
const BADGETH_LIBRARY_TEST_CONTRACT_NAME = "BadgethLibraryTest"

const BADGETH_MINTER_ROLE = solidityKeccak256(["string"], ["MINTER_ROLE"]);
const BADGETH_BURNER_ROLE = solidityKeccak256(["string"], ["BURNER_ROLE"]);
const BADGETH_ORACLE_ROLE = solidityKeccak256(["string"], ["ORACLE_ROLE"]);

const BADGETH_GQL_ENDPOINT = "https://api.studio.thegraph.com/query/2486/test/2.1.6";


const BADGETH_EARNED_BADGE_COUNT_QUERY = gql`
    query getMerkleLeaves($startingIndex: Int, $treeSize: Int) {
        earnedBadgeCounts(first: $treeSize, skip: $startingIndex, orderBy: globalBadgeNumber) {
            earnedBadge {
                badgeWinner {
                    id
                }
                definition {
                    badgeDefinitionNumber
                }
            }
        }
    }`

// this should be one of the known badges returned by BADGETH_GQL_QUERY
const BADGE_STRUCT = {
  winner: "0x819fd65026848d710fe40d8c0439f1220e069398",
  badgeDefinitionNumber: 1
};


describe("BadgethLibrary", function () {
  it("Should hash badges with results equivalent to ethers.utils", async function () {
    const badgethLibraryTestContract = await deployBadgethLibraryTestContract();
    const hashedBadge = await badgethLibraryTestContract.hashBadge(BADGE_STRUCT);
    const javascriptTestHash = hashBadgeStruct(BADGE_STRUCT);
    expect(hashedBadge).to.equal(javascriptTestHash);
  });
});

describe("Badge Merkle Drop", function () {

  it("Should verify merkle proofs generated by javascript", async function () {
    const client = new GraphQLClient(BADGETH_GQL_ENDPOINT);
    const success = await proveAllLeavesFromTree(0, 256, client)
    expect (success).to.equal(true);
  });
});


////////////////// HELPERS //////////////////

function hashBadgeStruct(badgeStruct) {
  let hashedBadge = ethers.utils.solidityKeccak256(
    ['address', 'int8'],
    [badgeStruct.winner, badgeStruct.badgeDefinitionNumber]
  );
  return hashedBadge;
}

function hashEarnedBadge(earnedBadge) {
  let hashedBadge = ethers.utils.solidityKeccak256(
    ['address', 'int8'],
    [earnedBadge.badgeWinner.id, earnedBadge.definition.badgeDefinitionNumber]
  );
  return hashedBadge;
}

async function proveAllLeavesFromTree(_startingIndex, _treeSize, client) {
  const leaves = await getLeavesFromSubgraph(_startingIndex, _treeSize, client);
  const hashedLeaves = leaves.map(earnedBadgeCount => hashEarnedBadge(earnedBadgeCount.earnedBadge));
  const tree = new MerkleTree(hashedLeaves, keccak256, { sortPairs: false });
  const badgethLibraryTestContract = await deployBadgethLibraryTestContract();

  let success = true;
  for (let i = 0; i < leaves.length; i++) {
      const earnedBadge = {
          winner: leaves[i].earnedBadge.badgeWinner.id,
          badgeDefinitionNumber: leaves[i].earnedBadge.definition.badgeDefinitionNumber
      };
      const proof = tree.getHexProof(hashedLeaves[i]);
      const positions = tree.getProof(hashedLeaves[i]).map(x => x.position === 'right' ? 1 : 0);

      success = await badgethLibraryTestContract.verifyBadge(
          earnedBadge, 
          proof, 
          positions, 
          tree.getHexRoot()
      );
      if (!success) break;
  }
  return success;
}

async function getLeavesFromSubgraph(_startingIndex, _treeSize, client) {
  const variables = {
      startingIndex: _startingIndex,
      treeSize: _treeSize
  };

  const earnedBadgeCounts = (await client.request(BADGETH_EARNED_BADGE_COUNT_QUERY, variables)).earnedBadgeCounts;
  return earnedBadgeCounts;
}

async function deployBadgethLibraryContract() {
  const badgethLibraryContractFactory = await ethers.getContractFactory(BADGETH_LIBRARY_CONTRACT_NAME);
  const badgethLibraryContract = await badgethLibraryContractFactory.deploy();
  await badgethLibraryContract.deployed();
  return badgethLibraryContract;
}

async function deployBadgethLibraryTestContract() {
  // deploy library first
  const badgethLibraryContract = await deployBadgethLibraryContract();
  const badgethLibraryTestContractFactory = await ethers.getContractFactory(
    BADGETH_LIBRARY_TEST_CONTRACT_NAME,
    {
      libraries: {
        BadgethLibrary: badgethLibraryContract.address
      }
    }
  );
  const badgethLibraryTestContract = await badgethLibraryTestContractFactory.deploy();
  await badgethLibraryTestContract.deployed();
  return badgethLibraryTestContract;
}